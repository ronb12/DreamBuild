// Database Module - Generated by DreamBuild Built-in AI

class DatabaseManager {
  constructor() {
    this.data = new Map()
    this.listeners = new Map()
  }

  // Generic CRUD operations
  async create(collection, data) {
    const id = Date.now().toString()
    const item = { id, ...data, createdAt: new Date() }
    
    if (!this.data.has(collection)) {
      this.data.set(collection, new Map())
    }
    
    this.data.get(collection).set(id, item)
    this.notifyListeners(collection, 'create', item)
    return item
  }

  async read(collection, id = null) {
    if (!this.data.has(collection)) {
      return id ? null : []
    }
    
    const collectionData = this.data.get(collection)
    
    if (id) {
      return collectionData.get(id) || null
    }
    
    return Array.from(collectionData.values())
  }

  async update(collection, id, updates) {
    if (!this.data.has(collection)) {
      return null
    }
    
    const item = this.data.get(collection).get(id)
    if (!item) {
      return null
    }
    
    const updatedItem = { ...item, ...updates, updatedAt: new Date() }
    this.data.get(collection).set(id, updatedItem)
    this.notifyListeners(collection, 'update', updatedItem)
    return updatedItem
  }

  async delete(collection, id) {
    if (!this.data.has(collection)) {
      return false
    }
    
    const deleted = this.data.get(collection).delete(id)
    if (deleted) {
      this.notifyListeners(collection, 'delete', { id })
    }
    return deleted
  }

  // Real-time subscriptions
  subscribe(collection, callback) {
    if (!this.listeners.has(collection)) {
      this.listeners.set(collection, new Set())
    }
    this.listeners.get(collection).add(callback)
    
    return () => {
      this.listeners.get(collection).delete(callback)
    }
  }

  notifyListeners(collection, operation, data) {
    if (this.listeners.has(collection)) {
      this.listeners.get(collection).forEach(callback => {
        callback(operation, data)
      })
    }
  }

  // Query methods
  async query(collection, filter) {
    const items = await this.read(collection)
    return items.filter(item => {
      return Object.entries(filter).every(([key, value]) => {
        return item[key] === value
      })
    })
  }

  // Search method
  async search(collection, searchTerm, fields = []) {
    const items = await this.read(collection)
    return items.filter(item => {
      const searchFields = fields.length > 0 ? fields : Object.keys(item)
      return searchFields.some(field => {
        const value = item[field]
        return typeof value === 'string' && 
               value.toLowerCase().includes(searchTerm.toLowerCase())
      })
    })
  }
}

export default new DatabaseManager()